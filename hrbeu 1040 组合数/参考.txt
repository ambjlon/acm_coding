

 这道题需要用到几个简单的数学结论。
1、用double型有时确实可以存放大数并且避免溢出，但是这绝对不是一个好方法。int和double的反复切换极容易引起截断错误（上边的代码编译后就得到"convert from double to int" 的警告，在java里根本就通不过编译，必须进行强制类型转换，也就是说编译器已经不做任何保证）。而且在大到一定程度后，double的误差会非常大。
2、任意n个相邻整数的乘积一定能被n!整除，所以可以考虑直接用整数进行除法运算并且保证不会出现舍去的情况，当然需要调整运算顺序。
3、C(m,n)=C(m-n,n)。 
 





可以考虑先除再乘的方法解决溢出问题:
从N个里取M个实际上是SUM=N*(N-1)*...*(N-M+1)/M! 可以考虑SUM=N/1*(N-1)/2*(N-2)/3*...*(N-M+1)/M 令N/1,(N-1)/2,(N-2)/3,...,(N-M+1)/M分别为A1,A2,A3,...,AM. 则: A1 对应从N个里取1个 A1*A2 对应从N个里取2个 A1*A2*A3 对应从N个里取3个 A1*A2*A3*...*AM 对应从N个里取M个 所以A1*A2*...*AI肯定为整数（I〈=M）。 从以上分析可以用以下做法： 
sum=1; 
 for (int i=n-m+1,j=1;i<=n,j<=m;i++,j++)            
 sum=sum*i/j;       
  //相当于从n个里取j个，肯定能整除 !!!!!!!!!!!!!!!!  
    printf("%d\n",sum); 
例如:本校1040 


可以考虑先除再乘的方法解决溢出问题:
从N个里取M个实际上是SUM=N*(N-1)*...*(N-M+1)/M! 可以考虑SUM=N/1*(N-1)/2*(N-2)/3*...*(N-M+1)/M 令N/1,(N-1)/2,(N-2)/3,...,(N-M+1)/M分别为A1,A2,A3,...,AM. 则: A1 对应从N个里取1个 A1*A2 对应从N个里取2个 A1*A2*A3 对应从N个里取3个 A1*A2*A3*...*AM 对应从N个里取M个 所以A1*A2*...*AI肯定为整数（I〈=M）。 从以上分析可以用以下做法： 
sum=1; 
 for (int i=n-m+1,j=1;i<=n,j<=m;i++,j++)            
 sum=sum*i/j;       
  //相当于从n个里取j个，肯定能整除   
    printf("%d\n",sum); 
例如:本校1040 


